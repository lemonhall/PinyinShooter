<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>汉字音调大作战</title>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.2.1/dist/pixi.min.js"></script>
  <style>
    body { margin: 0; background: #f0f0f0; }
    #game-container { position: relative; }
    .tone-btn { font-size: 24px; margin: 5px; padding: 10px 15px; }
  </style>
</head>
<body>
  <!-- 添加游戏容器 -->
  <div id="game-container">
    <div id="controls" style="text-align: center; margin-top: 20px;">
      <button class="tone-btn" data-tone="1">一声 ¯</button>
      <button class="tone-btn" data-tone="2">二声 ˊ</button>
      <button class="tone-btn" data-tone="3">三声 ˇ</button>
      <button class="tone-btn" data-tone="4">四声 ˋ</button>
    </div>
  </div>

  <script>
    // 等待DOM加载完成
    document.addEventListener('DOMContentLoaded', async () => {
      // 初始化游戏
      const app = new PIXI.Application();
      await app.init({
        width: 800,
        height: 500,
        backgroundColor: 0xE8F4FF
      });
      
      // 确保正确插入canvas
      const container = document.getElementById('game-container');
      container.insertBefore(app.view, container.firstChild);

      // 游戏数据
      const characters = [
        { char: '猫', pinyin: 'māo', tone: 1 },
        { char: '狗', pinyin: 'gǒu', tone: 3 },
        { char: '书', pinyin: 'shū', tone: 1 },
        { char: '笔', pinyin: 'bǐ', tone: 3 },
        { char: '水', pinyin: 'shuǐ', tone: 3 },
        { char: '火', pinyin: 'huǒ', tone: 3 },
        { char: '山', pinyin: 'shān', tone: 1 },
        { char: '人', pinyin: 'rén', tone: 2 }
      ];

      let currentTarget = null;
      let targetHealth = 0;
      let currentTargetSprite = null; // 新增：存储当前目标的 PIXI 对象
      let currentTargetTickerCallback = null; // 新增：存储当前目标的 Ticker 回调
      const attackPower = 15;

      // 新增：玩家数据
      let playerHealth = 100; // 初始生命值
      const playerPosition = { x: 400, y: 450 }; // 玩家基准位置 (底部中间)
      let playerSprite = null; // 玩家的 PIXI 对象
      let healthText = null; // 显示生命值的 PIXI.Text 对象
      // let playerScore = 0; // 如果需要分数，取消注释
      // let scoreText = null;

      // 创建操作区
      const controlArea = new PIXI.Graphics()
        .beginFill(0xFFFFFF, 0.7)
        .drawRect(0, app.screen.height - 100, app.screen.width, 100)
        .endFill();
      app.stage.addChild(controlArea);

      // 创建玩家图形 (一个简单的矩形)
      playerSprite = new PIXI.Graphics()
        .beginFill(0x0000FF) // 蓝色
        .drawRect(0, 0, 80, 20) // 宽度80, 高度20
        .endFill();
      playerSprite.x = playerPosition.x - playerSprite.width / 2; // 居中放置
      playerSprite.y = playerPosition.y - playerSprite.height / 2;
      app.stage.addChild(playerSprite);
      console.log("玩家已创建并添加到舞台");

      // 创建生命值文本
      healthText = new PIXI.Text(`生命值: ${playerHealth}`, {
        fontFamily: 'Arial',
        fontSize: 20,
        fill: 0x000000 // 黑色
      });
      healthText.x = 10; // 放在左上角
      healthText.y = 10;
      app.stage.addChild(healthText);
      console.log("生命值文本已创建");

      // 创建汉字按钮
      function createCharacterButtons() {
        // 随机选择4个汉字
        const shuffled = [...characters].sort(() => Math.random() - 0.5).slice(0, 4);
        
        shuffled.forEach((charObj, i) => {
          const btn = new PIXI.Text(charObj.char, {
            fontFamily: 'Arial',
            fontSize: 36,
            fill: 0x333333
          });
          btn.interactive = true;
          btn.cursor = 'pointer';
          btn.x = 100 + i * 150;
          btn.y = app.screen.height - 70;
          btn.charData = charObj;
          
          app.stage.addChild(btn);
        });
      }

      // 创建飞来的目标
      function createFlyingTarget() {
        // 随机选择一个汉字
        const targetCharIndex = Math.floor(Math.random() * characters.length);
        const targetChar = characters[targetCharIndex];

        // 确保获取到有效的字符数据
        if (!targetChar) {
          console.error("无法获取目标汉字数据!", { index: targetCharIndex, characters });
          // 可以在这里添加一些错误处理逻辑，比如延迟后重试
          setTimeout(createFlyingTarget, 1000); // 1秒后重试
          return;
        }

        console.log("创建新目标:", targetChar.char);
        currentTarget = targetChar;
        targetHealth = 30; // 重置生命值
        
        const target = new PIXI.Text(currentTarget.char, { // target 是 PIXI.Text 对象
          fontFamily: 'Arial',
          fontSize: 48,
          fill: 0xFF0000
        });
        // 修改初始位置：从顶部随机 x 位置开始
        target.x = Math.random() * (app.screen.width - target.width); // 随机 X，减去宽度防止部分在屏幕外
        target.y = -target.height; // 从屏幕顶部外开始
        target.charData = currentTarget;

        currentTargetSprite = target; // 存储当前目标的 Sprite
        
        app.stage.addChild(target);
        console.log(`目标 '${currentTarget.char}' 已添加到舞台...`);

        const move = (ticker) => {
          const delta = ticker.deltaTime;
          const speed = 2.5; // 调整移动速度

          // 计算朝向玩家的方向向量
          const dx = playerPosition.x - target.x;
          const dy = playerPosition.y - target.y;
          const length = Math.sqrt(dx * dx + dy * dy);

          // 如果距离大于一个很小的值 (避免除以0)，则移动
          if (length > 1) { // 用大于1像素来判断，避免浮点误差
            const normalizedDx = dx / length;
            const normalizedDy = dy / length;

            target.x += normalizedDx * speed * delta;
            target.y += normalizedDy * speed * delta;
          } else {
             // 如果已经非常接近或到达目标点，可以视为碰撞（或者让碰撞检测处理）
             // 这里暂时不移动，让下面的碰撞检测逻辑生效
             console.log(`目标 '${currentTarget.char}' 已到达玩家位置区域`);
          }
          
          // target.y += 3 * delta; // 旧的垂直向下移动

          // 碰撞检测逻辑保持不变
          const enemyBoundsRect = target.getBounds().rectangle;
          const playerBoundsRect = playerSprite.getBounds().rectangle;

          if (enemyBoundsRect && playerBoundsRect && enemyBoundsRect.intersects(playerBoundsRect)) {
             console.log(`目标 '${currentTarget.char}' 击中玩家!`);

             // 减少玩家生命值
             playerHealth -= 10; // 每次击中减少 10 点生命值
             healthText.text = `生命值: ${playerHealth}`; // 更新显示
             console.log(`玩家生命值剩余: ${playerHealth}`);

             // (可选) 可以在这里添加玩家被击中的视觉/音效反馈

             // 移除敌人
             app.ticker.remove(move);
             if (app.stage.children.includes(target)) {
               app.stage.removeChild(target);
             }

             // 清理当前目标状态
             currentTarget = null;
             currentTargetSprite = null;
             currentTargetTickerCallback = null;

             // 判断游戏是否结束
             if (playerHealth <= 0) {
               console.log("游戏结束!");
               healthText.text = "游戏结束!"; // 更新文本提示
               // (待实现) 显示游戏结束画面或提示
               app.ticker.stop(); // 停止所有 ticker 更新，暂停游戏
             } else {
               // 生成下一个敌人
               setTimeout(createFlyingTarget, 500); // 短暂延迟后生成下一个
             }
           }
           // 保留原来的移出屏幕底部的逻辑作为备用，以防万一
           else if (target.y > app.screen.height + 20) { // 增加一点缓冲
              console.log(`目标 '${currentTarget.char}' 已移出屏幕底部 (未击中)`);
              app.ticker.remove(move);
              if (app.stage.children.includes(target)) {
                  app.stage.removeChild(target);
              }
              currentTarget = null;
              currentTargetSprite = null;
              currentTargetTickerCallback = null;
              setTimeout(createFlyingTarget, 800); // 创建下一个
          }
        };
        currentTargetTickerCallback = move; // 存储当前目标的 Ticker 回调
        app.ticker.add(move);
      }

      // 检查答案 - 现在检查声调
      function checkAnswer(selectedTone) {
        if (!currentTarget) {
          console.log("当前没有目标，无法检查答案");
          return; // 如果没有目标，则不执行任何操作
        }

        console.log(`检查答案: 目标 '${currentTarget.char}'(tone ${currentTarget.tone}), 选择 tone ${selectedTone}`); // 日志

        if (selectedTone === currentTarget.tone) {
          targetHealth -= attackPower;
          console.log(`声调正确! 目标 '${currentTarget.char}' 生命值剩余: ${targetHealth}`);

          // 检查是否击毁
          if (targetHealth <= 0) {
            console.log(`目标 '${currentTarget.char}' 已击毁!`);

            // 停止移动并移除旧目标
            if (currentTargetTickerCallback) {
              app.ticker.remove(currentTargetTickerCallback);
            }
            if (currentTargetSprite && app.stage.children.includes(currentTargetSprite)) {
              app.stage.removeChild(currentTargetSprite);
            }

            // 显示击毁效果
            const boom = new PIXI.Text('💥 击毁!', {
              fontFamily: 'Arial',
              fontSize: 36,
              fill: 0xFF4500
            });
            // 定位到被击毁目标的位置
            if (currentTargetSprite) {
                 boom.x = currentTargetSprite.x;
                 boom.y = currentTargetSprite.y;
            } else { // 如果 sprite 意外丢失，放在屏幕中间
                 boom.x = app.screen.width / 2 - boom.width / 2;
                 boom.y = app.screen.height / 2 - boom.height / 2;
            }
            app.stage.addChild(boom);
            
            // 清理全局状态
            currentTarget = null;
            currentTargetSprite = null;
            currentTargetTickerCallback = null;

            // 准备下一个目标，并移除击毁效果
            setTimeout(() => {
              if (app.stage.children.includes(boom)) {
                 app.stage.removeChild(boom);
              }
              createFlyingTarget();
            }, 800); // 延迟后创建新目标

          } else {
            // 未击毁，仅显示命中效果
            const hitText = new PIXI.Text('✓ 正确!', {
              fontFamily: 'Arial',
              fontSize: 24,
              fill: 0x00FF00
            });
            hitText.x = app.screen.width / 2 - 50;
            hitText.y = 50;
            app.stage.addChild(hitText);
            
            setTimeout(() => {
              if (app.stage.children.includes(hitText)) {
                  app.stage.removeChild(hitText);
              }
            }, 500);
          }
        } else {
          // 错误反馈
          console.log(`声调错误! 目标 '${currentTarget.char}' 需要 tone ${currentTarget.tone}, 选择了 tone ${selectedTone}`); // 日志
          const missText = new PIXI.Text('✗ 声调错误!', { // 更新提示信息
            fontFamily: 'Arial',
            fontSize: 24,
            fill: 0xFF0000
          });
          missText.x = app.screen.width / 2 - 50;
          missText.y = 50;
          app.stage.addChild(missText);
          
          setTimeout(() => {
            app.stage.removeChild(missText);
          }, 500);
        }
      }

      // 初始化游戏
      createCharacterButtons();
      createFlyingTarget();

      // 绑定音调按钮 - 调用新的 checkAnswer
      document.querySelectorAll('.tone-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const tone = parseInt(btn.dataset.tone);
          // alert(`你选择了 ${btn.textContent}，后续可以扩展音调验证功能`); // 移除 alert
          if (currentTarget) { // 确保有目标时才检查
             checkAnswer(tone); // 调用新的 checkAnswer，传入声调
          } else {
             console.log("点击声调按钮，但当前无目标");
          }
        });
      });
    });
  </script>
</body>
</html>
