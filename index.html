<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>汉字音调大作战</title>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.2.1/dist/pixi.min.js"></script>
  <style>
    body { margin: 0; background: #f0f0f0; }
    #game-container { position: relative; }
    .tone-btn { font-size: 24px; margin: 5px; padding: 10px 15px; }
  </style>
</head>
<body>
  <!-- 添加游戏容器 -->
  <div id="game-container">
    <div id="controls" style="text-align: center; margin-top: 20px;">
      <button class="tone-btn" data-tone="1">一声 ¯</button>
      <button class="tone-btn" data-tone="2">二声 ˊ</button>
      <button class="tone-btn" data-tone="3">三声 ˇ</button>
      <button class="tone-btn" data-tone="4">四声 ˋ</button>
    </div>
  </div>

  <script>
    // 等待DOM加载完成
    document.addEventListener('DOMContentLoaded', async () => {
      // 初始化游戏
      const app = new PIXI.Application();
      await app.init({
        width: 800,
        height: 500,
        backgroundColor: 0xE8F4FF
      });
      
      // 确保正确插入canvas
      const container = document.getElementById('game-container');
      container.insertBefore(app.view, container.firstChild);

      // 游戏数据
      const characters = [
        { char: '猫', pinyin: 'māo', tone: 1, emoji: '🐱' },
        { char: '狗', pinyin: 'gǒu', tone: 3, emoji: '🐶' },
        { char: '书', pinyin: 'shū', tone: 1, emoji: '📖' },
        { char: '笔', pinyin: 'bǐ', tone: 3, emoji: '✏️' },
        { char: '水', pinyin: 'shuǐ', tone: 3, emoji: '💧' },
        { char: '火', pinyin: 'huǒ', tone: 3, emoji: '🔥' },
        { char: '山', pinyin: 'shān', tone: 1, emoji: '⛰️' },
        { char: '人', pinyin: 'rén', tone: 2, emoji: '🧑' },
        { char: '天', pinyin: 'tiān', tone: 1, emoji: '☀️' },
        { char: '地', pinyin: 'dì', tone: 4, emoji: '🌍' },
        { char: '月', pinyin: 'yuè', tone: 4, emoji: '🌙' },
        { char: '日', pinyin: 'rì', tone: 4, emoji: '☀️' },
        { char: '星', pinyin: 'xīng', tone: 1, emoji: '⭐' },
        { char: '云', pinyin: 'yún', tone: 2, emoji: '☁️' },
        { char: '风', pinyin: 'fēng', tone: 1, emoji: '🌬️' },
        { char: '雨', pinyin: 'yǔ', tone: 3, emoji: '🌧️' },
        { char: '电', pinyin: 'diàn', tone: 4, emoji: '⚡' },
        { char: '花', pinyin: 'huā', tone: 1, emoji: '🌸' },
        { char: '草', pinyin: 'cǎo', tone: 3, emoji: '🌿' },
        { char: '树', pinyin: 'shù', tone: 4, emoji: '🌳' },
        { char: '鸟', pinyin: 'niǎo', tone: 3, emoji: '🐦' },
        { char: '鱼', pinyin: 'yú', tone: 2, emoji: '🐟' },
        { char: '马', pinyin: 'mǎ', tone: 3, emoji: '🐎' },
        { char: '牛', pinyin: 'niú', tone: 2, emoji: '🐂' },
        { char: '羊', pinyin: 'yáng', tone: 2, emoji: '🐑' },
        { char: '左', pinyin: 'zuǒ', tone: 3, emoji: '👈' },
        { char: '右', pinyin: 'yòu', tone: 4, emoji: '👉' },
        { char: '大', pinyin: 'dà', tone: 4, emoji: '🐘' },
        { char: '小', pinyin: 'xiǎo', tone: 3, emoji: '🐭' },
        { char: '车', pinyin: 'chē', tone: 1, emoji: '🚗' },
        { char: '船', pinyin: 'chuán', tone: 2, emoji: '🚢' },
        { char: '门', pinyin: 'mén', tone: 2, emoji: '🚪' },
        { char: '刀', pinyin: 'dāo', tone: 1, emoji: '🔪' },
        { char: '衣', pinyin: 'yī', tone: 1, emoji: '👕' },
        { char: '食', pinyin: 'shí', tone: 2, emoji: '🍔' },
        { char: '住', pinyin: 'zhù', tone: 4, emoji: '🏠' },
        { char: '行', pinyin: 'xíng', tone: 2, emoji: '🚶' },
        { char: '手', pinyin: 'shǒu', tone: 3, emoji: '✋' },
        { char: '足', pinyin: 'zú', tone: 2, emoji: '🦶' },
        { char: '头', pinyin: 'tóu', tone: 2, emoji: '👤' },
        { char: '心', pinyin: 'xīn', tone: 1, emoji: '❤️' },
        { char: '眼', pinyin: 'yǎn', tone: 3, emoji: '👀' },
        { char: '耳', pinyin: 'ěr', tone: 3, emoji: '👂' },
        { char: '口', pinyin: 'kǒu', tone: 3, emoji: '👄' },
        { char: '鼻', pinyin: 'bí', tone: 2, emoji: '👃' },
        { char: '笑', pinyin: 'xiào', tone: 4, emoji: '😄' },
        { char: '哭', pinyin: 'kū', tone: 1, emoji: '😭' },
        { char: '爱', pinyin: 'ài', tone: 4, emoji: '❤️' },
        { char: '钱', pinyin: 'qián', tone: 2, emoji: '💰' },
        { char: '球', pinyin: 'qiú', tone: 2, emoji: '⚽' },
        { char: '灯', pinyin: 'dēng', tone: 1, emoji: '💡' },
        { char: '画', pinyin: 'huà', tone: 4, emoji: '🖼️' },
        { char: '唱', pinyin: 'chàng', tone: 4, emoji: '🎤' },
        { char: '跳', pinyin: 'tiào', tone: 4, emoji: '💃' },
        { char: '跑', pinyin: 'pǎo', tone: 3, emoji: '🏃' },
        { char: '飞', pinyin: 'fēi', tone: 1, emoji: '✈️' },
        { char: '坐', pinyin: 'zuò', tone: 4, emoji: '🪑' },
        { char: '站', pinyin: 'zhàn', tone: 4, emoji: '🧍' }
      ];

      let currentTarget = null;
      let targetHealth = 0;
      let currentTargetSprite = null; // 新增：存储当前目标的 PIXI 对象
      let currentTargetTickerCallback = null; // 新增：存储当前目标的 Ticker 回调
      const attackPower = 15;

      // 新增：玩家数据
      let playerHealth = 100; // 初始生命值
      const playerPosition = { x: 400, y: 450 }; // 玩家基准位置 (底部中间)
      let playerSprite = null; // 玩家的 PIXI 对象
      let healthText = null; // 显示生命值的 PIXI.Text 对象
      // let playerScore = 0; // 如果需要分数，取消注释
      // let scoreText = null;

      // 创建操作区
      const controlArea = new PIXI.Graphics()
        .beginFill(0xFFFFFF, 0.7)
        .drawRect(0, app.screen.height - 100, app.screen.width, 100)
        .endFill();
      app.stage.addChild(controlArea);

      // 创建玩家图形 (使用 SVG 盾牌)
      const playerSvgString = '<svg width="60" height="70" viewBox="0 0 60 70" xmlns="http://www.w3.org/2000/svg"><path d="M 5 15 A 25 25 0 0 1 55 15 L 55 50 L 30 65 L 5 50 Z" fill="dodgerblue" stroke="black" stroke-width="2"/></svg>';
      playerSprite = new PIXI.Graphics().svg(playerSvgString);

      /* // 移除旧的矩形绘制代码
      playerSprite = new PIXI.Graphics()
        .beginFill(0x0000FF) // 蓝色
        .drawRect(0, 0, 80, 20) // 宽度80, 高度20
        .endFill();
      */

      // 定位玩家 (基于新的 SVG 图形尺寸自动计算居中)
      playerSprite.x = playerPosition.x - playerSprite.width / 2; 
      playerSprite.y = playerPosition.y - playerSprite.height / 2;
      app.stage.addChild(playerSprite);
      console.log("玩家 (SVG盾牌) 已创建并添加到舞台");

      // 创建生命值文本
      healthText = new PIXI.Text(`生命值: ${playerHealth}`, {
        fontFamily: 'Arial',
        fontSize: 20,
        fill: 0x000000 // 黑色
      });
      healthText.x = 10; // 放在左上角
      healthText.y = 10;
      app.stage.addChild(healthText);
      console.log("生命值文本已创建");

      // 创建汉字按钮 (现在注释掉，因为不再需要)
      // createCharacterButtons();

      // 创建飞来的目标 (组合形式：敌人 + 头顶文字)
      function createFlyingTarget() {
        const targetCharIndex = Math.floor(Math.random() * characters.length);
        const targetChar = characters[targetCharIndex];

        if (!targetChar) {
          console.error("无法获取目标汉字数据!");
          setTimeout(createFlyingTarget, 1000);
          return;
        }

        console.log("创建新目标组合:", targetChar.char);
        currentTarget = targetChar;
        targetHealth = 30; // 重置生命值
        
        // 创建 Container
        const targetContainer = new PIXI.Container();
        targetContainer.charData = currentTarget; // 将数据关联到 Container

        // 1. 创建敌人 Emoji 文本
        const enemyEmojiText = new PIXI.Text(currentTarget.emoji, {
          fontFamily: 'Arial', // 确保字体支持 Emoji
          fontSize: 40 // Emoji 字号可以大一些
        });
        // 将 Emoji 放在 Container 的 (0, 0) 位置作为基准
        enemyEmojiText.x = 0;
        enemyEmojiText.y = 0;
        enemyEmojiText.anchor.set(0.5, 0.5); // 设置锚点为中心，方便定位
        targetContainer.addChild(enemyEmojiText);

        // 2. 创建汉字文本 (显示在 Emoji 上方)
        const charText = new PIXI.Text(currentTarget.char, {
          fontFamily: 'Arial',
          fontSize: 24, // 可以适当调小一点
          fill: 0x000000, // 黑色文字，更清晰
          align: 'center'
        });
        // 定位文字在 Emoji 头顶居中
        charText.anchor.set(0.5, 1); // 锚点设置在文字底部中心
        charText.x = enemyEmojiText.x; // 水平居中对齐 Emoji 中心
        charText.y = enemyEmojiText.y - enemyEmojiText.height / 2 - 5; // Emoji 中心点上方再减去 Emoji 高度一半，留 5px 间距
        targetContainer.addChild(charText);

        // 设置 Container 的初始位置 (基于新的内容)
        const containerBounds = targetContainer.getLocalBounds(); // 获取局部边界来估算尺寸
        targetContainer.x = Math.random() * (app.screen.width - containerBounds.width);
        targetContainer.y = -containerBounds.height; // 从屏幕顶部外开始

        currentTargetSprite = targetContainer; // 全局变量现在指向 Container
        
        app.stage.addChild(targetContainer);
        console.log(`目标组合 '${currentTarget.char}' 已添加到舞台...`);

        // 移动 Container 的逻辑
        const move = (ticker) => {
          const delta = ticker.deltaTime;
          const speed = 1.8; 

          // 计算朝向玩家的方向向量 (目标是 Container 的中心)
          const dx = playerPosition.x - (targetContainer.x + containerBounds.width / 2);
          const dy = playerPosition.y - (targetContainer.y + containerBounds.height / 2);
          const length = Math.sqrt(dx * dx + dy * dy);

          if (length > 1) { 
            const normalizedDx = dx / length;
            const normalizedDy = dy / length;
            targetContainer.x += normalizedDx * speed * delta;
            targetContainer.y += normalizedDy * speed * delta;
          }

          // 碰撞检测逻辑 (使用 Container 的边界)
          const enemyBoundsRect = targetContainer.getBounds().rectangle; 
          const playerBoundsRect = playerSprite.getBounds().rectangle; 

          if (enemyBoundsRect && playerBoundsRect && enemyBoundsRect.intersects(playerBoundsRect)) { 
             console.log(`目标组合 '${currentTarget.char}' 击中玩家!`);
             // 减少玩家生命值
             playerHealth -= 10; // 每次击中减少 10 点生命值
             healthText.text = `生命值: ${playerHealth}`; // 更新显示
             console.log(`玩家生命值剩余: ${playerHealth}`);

             // 移除敌人 Container
             app.ticker.remove(move);
             if (app.stage.children.includes(targetContainer)) { // 检查并移除 Container
               app.stage.removeChild(targetContainer);
             }

             // 判断游戏是否结束
             if (playerHealth <= 0) {
               console.log("游戏结束!");
               healthText.text = "游戏结束!"; // 更新文本提示
               // (待实现) 显示游戏结束画面或提示
               app.ticker.stop(); // 停止所有 ticker 更新，暂停游戏
             } else {
               setTimeout(createFlyingTarget, 500);
             }
           }
           // 移出屏幕底部的逻辑 (也要基于 Container)
           else if (targetContainer.y > app.screen.height + 20) {
              console.log(`目标组合 '${currentTarget.char}' 已移出屏幕底部 (未击中)`);
              app.ticker.remove(move);
              if (app.stage.children.includes(targetContainer)) {
                  app.stage.removeChild(targetContainer);
              }
              currentTarget = null;
              currentTargetSprite = null;
              currentTargetTickerCallback = null;
              setTimeout(createFlyingTarget, 800); 
          }
        };
        currentTargetTickerCallback = move; // 存储 Container 的 Ticker 回调
        app.ticker.add(move);
      }

      // 检查答案 - 击毁效果定位和移除需要对应 Container
      function checkAnswer(selectedTone) {
        if (!currentTarget) {
          console.log("当前没有目标，无法检查答案");
          return; // 如果没有目标，则不执行任何操作
        }

        console.log(`检查答案: 目标 '${currentTarget.char}'(tone ${currentTarget.tone}), 选择 tone ${selectedTone}`); // 日志

        if (selectedTone === currentTarget.tone) {
          targetHealth -= attackPower;
          console.log(`声调正确! 目标 '${currentTarget.char}' 生命值剩余: ${targetHealth}`);

          // 检查是否击毁
          if (targetHealth <= 0) {
            console.log(`目标组合 '${currentTarget.char}' 已击毁!`); // 更新日志

            // 停止移动并移除旧目标 Container
            if (currentTargetTickerCallback) {
              app.ticker.remove(currentTargetTickerCallback);
            }
            // 使用 currentTargetSprite (现在是 Container)
            if (currentTargetSprite && app.stage.children.includes(currentTargetSprite)) {
              app.stage.removeChild(currentTargetSprite); 
            }

            // 显示击毁效果 (定位到 Container 的位置)
            const boom = new PIXI.Text('💥 击毁!', {
              fontFamily: 'Arial',
              fontSize: 36,
              fill: 0xFF4500
            });
            if (currentTargetSprite) {
                 boom.x = currentTargetSprite.x + currentTargetSprite.width / 2 - boom.width / 2; // 居中
                 boom.y = currentTargetSprite.y + currentTargetSprite.height / 2 - boom.height / 2;
            } else { 
                 // ... (备用定位逻辑)
            }
            app.stage.addChild(boom);
            
            // 清理全局状态
            currentTarget = null;
            currentTargetSprite = null;
            currentTargetTickerCallback = null;

            // 准备下一个目标 Container
            setTimeout(() => {
              if (app.stage.children.includes(boom)) {
                 app.stage.removeChild(boom);
              }
              createFlyingTarget();
            }, 800); // 延迟后创建新目标 Container

          } else {
            // 未击毁，仅显示命中效果
            const hitText = new PIXI.Text('✓ 正确!', {
              fontFamily: 'Arial',
              fontSize: 24,
              fill: 0x00FF00
            });
            hitText.x = app.screen.width / 2 - 50;
            hitText.y = 50;
            app.stage.addChild(hitText);
            
            setTimeout(() => {
              if (app.stage.children.includes(hitText)) {
                  app.stage.removeChild(hitText);
              }
            }, 500);
          }
        } else {
          // 错误反馈
          console.log(`声调错误! 目标 '${currentTarget.char}' 需要 tone ${currentTarget.tone}, 选择了 tone ${selectedTone}`); // 日志
          const missText = new PIXI.Text('✗ 声调错误!', { // 更新提示信息
            fontFamily: 'Arial',
            fontSize: 24,
            fill: 0xFF0000
          });
          missText.x = app.screen.width / 2 - 50;
          missText.y = 50;
          app.stage.addChild(missText);
          
          setTimeout(() => {
            app.stage.removeChild(missText);
          }, 500);
        }
      }

      // 初始化游戏
      // createCharacterButtons();
      createFlyingTarget();

      // 绑定音调按钮 - 调用新的 checkAnswer
      document.querySelectorAll('.tone-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const tone = parseInt(btn.dataset.tone);
          // alert(`你选择了 ${btn.textContent}，后续可以扩展音调验证功能`); // 移除 alert
          if (currentTarget) { // 确保有目标时才检查
             checkAnswer(tone); // 调用新的 checkAnswer，传入声调
          } else {
             console.log("点击声调按钮，但当前无目标");
          }
        });
      });
    });
  </script>
</body>
</html>
