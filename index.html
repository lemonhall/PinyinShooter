<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>汉字音调大作战</title>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.2.1/dist/pixi.min.js"></script>
  <style>
    body { margin: 0; background: #f0f0f0; overflow: hidden; }
    #game-container { position: relative; }
    #controls { 
      text-align: center; 
      position: absolute;
      bottom: 10px;
      left: 0;
      width: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 10px 0;
      box-sizing: border-box;
      z-index: 10;
    }
    .tone-btn { 
      font-size: 48px;
      margin: 10px 12px;
      padding: 18px 25px;
    }
  </style>
</head>
<body>
  <!-- 添加游戏容器 -->
  <div id="game-container">
    <div id="controls">
      <button class="tone-btn" data-tone="1">一声 ¯</button>
      <button class="tone-btn" data-tone="2">二声 ˊ</button>
      <button class="tone-btn" data-tone="3">三声 ˇ</button>
      <button class="tone-btn" data-tone="4">四声 ˋ</button>
    </div>
  </div>

  <script>
    // Web Audio API 相关
    let audioCtx = null;

    function playCorrectSound() {
      if (!audioCtx) {
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.error("Web Audio API is not supported in this browser", e);
          return; // 不支持则无法播放
        }
      }

      // 检查 AudioContext 是否处于 suspended 状态 (常见于用户交互前)
      if (audioCtx.state === 'suspended') {
        audioCtx.resume(); // 尝试恢复
      }
      
      if (!audioCtx) return; // 如果创建失败或不支持，则退出

      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      oscillator.type = 'sine'; // 正弦波
      oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A5 音高

      // 控制音量，制造短促提示音效果
      const now = audioCtx.currentTime;
      const peakVolume = 0.4; // 不要太大声
      const duration = 0.15; // 声音持续时间
      gainNode.gain.setValueAtTime(0, now);
      gainNode.gain.linearRampToValueAtTime(peakVolume, now + duration * 0.2); // 快速上升
      gainNode.gain.linearRampToValueAtTime(0, now + duration); // 缓慢下降

      oscillator.start(now);
      oscillator.stop(now + duration);
    }

    // 添加 speak 函数
    function speak(text) {
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel(); 
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'zh-CN';
        utterance.rate = 0.9;
        window.speechSynthesis.speak(utterance);
      } else {
        console.warn("浏览器不支持语音合成 API");
      }
    }

    // 等待DOM加载完成
    document.addEventListener('DOMContentLoaded', async () => {
      // 初始化游戏
      const app = new PIXI.Application();
      await app.init({
        backgroundColor: 0xE8F4FF,
        resizeTo: window
      });
      
      // 确保正确插入canvas
      const container = document.getElementById('game-container');
      container.insertBefore(app.view, container.firstChild);

      // 游戏数据
      const characters = [
        { char: '猫', pinyin: 'māo', tone: 1, emoji: '🐱' },
        { char: '狗', pinyin: 'gǒu', tone: 3, emoji: '🐶' },
        { char: '书', pinyin: 'shū', tone: 1, emoji: '📖' },
        { char: '笔', pinyin: 'bǐ', tone: 3, emoji: '✏️' },
        { char: '水', pinyin: 'shuǐ', tone: 3, emoji: '💧' },
        { char: '火', pinyin: 'huǒ', tone: 3, emoji: '🔥' },
        { char: '山', pinyin: 'shān', tone: 1, emoji: '⛰️' },
        { char: '人', pinyin: 'rén', tone: 2, emoji: '🧑' },
        { char: '天', pinyin: 'tiān', tone: 1, emoji: '☀️' },
        { char: '地', pinyin: 'dì', tone: 4, emoji: '🌍' },
        { char: '月', pinyin: 'yuè', tone: 4, emoji: '🌙' },
        { char: '日', pinyin: 'rì', tone: 4, emoji: '☀️' },
        { char: '星', pinyin: 'xīng', tone: 1, emoji: '⭐' },
        { char: '云', pinyin: 'yún', tone: 2, emoji: '☁️' },
        { char: '风', pinyin: 'fēng', tone: 1, emoji: '🌬️' },
        { char: '雨', pinyin: 'yǔ', tone: 3, emoji: '🌧️' },
        { char: '电', pinyin: 'diàn', tone: 4, emoji: '⚡' },
        { char: '花', pinyin: 'huā', tone: 1, emoji: '🌸' },
        { char: '草', pinyin: 'cǎo', tone: 3, emoji: '🌿' },
        { char: '树', pinyin: 'shù', tone: 4, emoji: '🌳' },
        { char: '鸟', pinyin: 'niǎo', tone: 3, emoji: '🐦' },
        { char: '鱼', pinyin: 'yú', tone: 2, emoji: '🐟' },
        { char: '马', pinyin: 'mǎ', tone: 3, emoji: '🐎' },
        { char: '牛', pinyin: 'niú', tone: 2, emoji: '🐂' },
        { char: '羊', pinyin: 'yáng', tone: 2, emoji: '🐑' },
        { char: '左', pinyin: 'zuǒ', tone: 3, emoji: '👈' },
        { char: '右', pinyin: 'yòu', tone: 4, emoji: '👉' },
        { char: '大', pinyin: 'dà', tone: 4, emoji: '🐘' },
        { char: '小', pinyin: 'xiǎo', tone: 3, emoji: '🐭' },
        { char: '车', pinyin: 'chē', tone: 1, emoji: '🚗' },
        { char: '船', pinyin: 'chuán', tone: 2, emoji: '🚢' },
        { char: '门', pinyin: 'mén', tone: 2, emoji: '🚪' },
        { char: '刀', pinyin: 'dāo', tone: 1, emoji: '🔪' },
        { char: '衣', pinyin: 'yī', tone: 1, emoji: '👕' },
        { char: '食', pinyin: 'shí', tone: 2, emoji: '🍔' },
        { char: '住', pinyin: 'zhù', tone: 4, emoji: '🏠' },
        { char: '行', pinyin: 'xíng', tone: 2, emoji: '🚶' },
        { char: '手', pinyin: 'shǒu', tone: 3, emoji: '✋' },
        { char: '足', pinyin: 'zú', tone: 2, emoji: '🦶' },
        { char: '头', pinyin: 'tóu', tone: 2, emoji: '👤' },
        { char: '心', pinyin: 'xīn', tone: 1, emoji: '❤️' },
        { char: '眼', pinyin: 'yǎn', tone: 3, emoji: '👀' },
        { char: '耳', pinyin: 'ěr', tone: 3, emoji: '👂' },
        { char: '口', pinyin: 'kǒu', tone: 3, emoji: '👄' },
        { char: '鼻', pinyin: 'bí', tone: 2, emoji: '👃' },
        { char: '笑', pinyin: 'xiào', tone: 4, emoji: '😄' },
        { char: '哭', pinyin: 'kū', tone: 1, emoji: '😭' },
        { char: '爱', pinyin: 'ài', tone: 4, emoji: '❤️' },
        { char: '钱', pinyin: 'qián', tone: 2, emoji: '💰' },
        { char: '球', pinyin: 'qiú', tone: 2, emoji: '⚽' },
        { char: '灯', pinyin: 'dēng', tone: 1, emoji: '💡' },
        { char: '画', pinyin: 'huà', tone: 4, emoji: '🖼️' },
        { char: '唱', pinyin: 'chàng', tone: 4, emoji: '🎤' },
        { char: '跳', pinyin: 'tiào', tone: 4, emoji: '💃' },
        { char: '跑', pinyin: 'pǎo', tone: 3, emoji: '🏃' },
        { char: '飞', pinyin: 'fēi', tone: 1, emoji: '✈️' },
        { char: '坐', pinyin: 'zuò', tone: 4, emoji: '🪑' },
        { char: '站', pinyin: 'zhàn', tone: 4, emoji: '🧍' }
      ];

      let currentTarget = null;
      let targetHealth = 0;
      let currentTargetSprite = null; // 新增：存储当前目标的 PIXI 对象
      let currentTargetTickerCallback = null; // 新增：存储当前目标的 Ticker 回调
      const attackPower = 15;

      // 新增：玩家数据
      let playerHealth = 100; // 初始生命值
      let playerPosition = { x: 0, y: 0 }; // 改为变量，动态计算
      let playerSprite = null; // 玩家的 PIXI 对象
      let healthText = null; // 显示生命值的 PIXI.Text 对象
      // let playerScore = 0; // 如果需要分数，取消注释
      // let scoreText = null;

      // 创建操作区 (定义高度变量)
      const controlAreaHeight = 100;
      const controlArea = new PIXI.Graphics();
      app.stage.addChild(controlArea); // 先添加，后续在 updateLayout 中绘制 (现在不绘制了)

      // 创建玩家图形 (使用 SVG 盾牌)
      const playerSvgString = '<svg width="60" height="70" viewBox="0 0 60 70" xmlns="http://www.w3.org/2000/svg"><path d="M 5 15 A 25 25 0 0 1 55 15 L 55 50 L 30 65 L 5 50 Z" fill="dodgerblue" stroke="black" stroke-width="2"/></svg>';
      playerSprite = new PIXI.Graphics().svg(playerSvgString);
      playerSprite.scale.set(2.5, 2.5); // 将玩家盾牌放大到 2.5 倍
      console.log("玩家 (SVG盾牌) 已创建并添加到舞台，已缩放");

      // 定位玩家 (基于新的 SVG 图形尺寸自动计算居中)
      playerSprite.x = playerPosition.x - playerSprite.width / 2; 
      playerSprite.y = playerPosition.y - playerSprite.height / 2;
      app.stage.addChild(playerSprite);
      console.log("玩家 (SVG盾牌) 已创建并添加到舞台，已缩放");

      // 创建生命值文本
      healthText = new PIXI.Text(`生命值: ${playerHealth}`, {
        fontFamily: 'Arial',
        fontSize: 42,
        fill: 0x000000 // 黑色
      });
      healthText.x = 10; // 放在左上角
      healthText.y = 10;
      app.stage.addChild(healthText);
      console.log("生命值文本已创建");

      // 创建汉字按钮 (现在注释掉，因为不再需要)
      // createCharacterButtons();

      // 定义 updateLayout 函数
      function updateLayout() {
        console.log(`Updating layout for screen: ${app.screen.width}x${app.screen.height}`);
        // 更新玩家位置 (底部居中，根据按钮区域和放大的盾牌向上偏移)
        const controlsHeightEstimate = 160; // 再次调整底部按钮区域高度估算
        playerPosition.x = app.screen.width / 2;
        playerPosition.y = app.screen.height - (playerSprite.height * playerSprite.scale.y) / 2 - controlsHeightEstimate - 15; // 额外再向上移15px边距

        // 更新玩家 Sprite 位置
        if (playerSprite) {
             playerSprite.x = playerPosition.x - playerSprite.width / 2; 
             playerSprite.y = playerPosition.y - playerSprite.height / 2;
        }

        // 更新操作区绘制 (不再需要绘制画布上的操作区)
        /*
        controlArea.clear(); // 清除旧的绘制
        controlArea.beginFill(0xFFFFFF, 0.7)
                   .drawRect(0, app.screen.height - controlAreaHeight, app.screen.width, controlAreaHeight)
                   .endFill();
        */
      }

      // 创建飞来的目标 (组合形式：敌人 + 头顶文字)
      function createFlyingTarget() {
        const targetCharIndex = Math.floor(Math.random() * characters.length);
        const targetChar = characters[targetCharIndex];

        if (!targetChar) {
          console.error("无法获取目标汉字数据!");
          setTimeout(createFlyingTarget, 1000);
          return;
        }

        console.log("创建新目标组合:", targetChar.char);
        currentTarget = targetChar;
        targetHealth = 30; // 重置生命值
        
        // 创建 Container
        const targetContainer = new PIXI.Container();
        targetContainer.charData = currentTarget; // 将数据关联到 Container

        // 1. 创建敌人 Emoji 文本 (添加 name)
        const enemyEmojiText = new PIXI.Text(currentTarget.emoji, { 
            fontFamily: 'Arial', 
            fontSize: 100 /* 再次增大 Emoji */
        });
        enemyEmojiText.name = 'emojiText'; // 添加名称
        enemyEmojiText.x = 0;
        enemyEmojiText.y = 0;
        enemyEmojiText.anchor.set(0.5, 0.5);
        targetContainer.addChild(enemyEmojiText);

        // 2. 创建汉字文本 (添加 name)
        const charText = new PIXI.Text(currentTarget.char, { 
            fontFamily: 'Arial', 
            fontSize: 56,
            fill: 0x000000, align: 'center' 
        });
        charText.name = 'hanziText'; // 添加名称
        charText.anchor.set(0.5, 1);
        charText.x = enemyEmojiText.x;
        charText.y = enemyEmojiText.y - enemyEmojiText.height / 2 - 5;
        targetContainer.addChild(charText);

        // 设置 Container 的初始位置 (基于新的内容)
        const containerBounds = targetContainer.getLocalBounds(); // 获取局部边界来估算尺寸
        targetContainer.x = Math.random() * (app.screen.width - containerBounds.width);
        targetContainer.y = -containerBounds.height; // 从屏幕顶部外开始

        currentTargetSprite = targetContainer; 
        app.stage.addChild(targetContainer);
        console.log(`目标组合 '${currentTarget.char}' 已添加到舞台...`);

        // **朗读汉字**
        speak(currentTarget.char);

        // 移动 Container 的逻辑
        const move = (ticker) => { 
          const delta = ticker.deltaTime;
          const speed = 1.5; // 加快速度 (原为 0.8)

          // 计算朝向玩家的方向向量 (目标是 Container 的中心)
          const dx = playerPosition.x - (targetContainer.x + containerBounds.width / 2);
          const dy = playerPosition.y - (targetContainer.y + containerBounds.height / 2);
          const length = Math.sqrt(dx * dx + dy * dy);

          if (length > 1) { 
            const normalizedDx = dx / length;
            const normalizedDy = dy / length;
            targetContainer.x += normalizedDx * speed * delta;
            targetContainer.y += normalizedDy * speed * delta;
          }

          // 碰撞检测逻辑
          const enemyBoundsRect = targetContainer.getBounds().rectangle; 
          const playerBoundsRect = playerSprite.getBounds().rectangle; 

          if (enemyBoundsRect && playerBoundsRect && enemyBoundsRect.intersects(playerBoundsRect)) { 
             console.log(`目标组合 '${currentTarget.char}' 击中玩家!`);
             // 减少玩家生命值
             playerHealth -= 10; // 每次击中减少 10 点生命值
             healthText.text = `生命值: ${playerHealth}`; // 更新显示
             console.log(`玩家生命值剩余: ${playerHealth}`);

             // 移除敌人
             app.ticker.remove(move);
             if (app.stage.children.includes(targetContainer)) {
                app.stage.removeChild(targetContainer);
             }
             // 清理状态
             const hitTargetData = currentTarget; 
             currentTarget = null;
             currentTargetSprite = null;
             currentTargetTickerCallback = null;

             if (playerHealth <= 0) {
               console.log("游戏结束!");
               healthText.text = "游戏结束!"; // 更新文本提示
               // (待实现) 显示游戏结束画面或提示
               app.ticker.stop(); // 停止所有 ticker 更新，暂停游戏
             } else {
                console.log(`玩家被 ${hitTargetData?.char || '未知目标'} 击中，准备生成下一个`);
                setTimeout(() => {
                     if (!currentTarget) { 
                        createFlyingTarget();
                     }
                }, 500); 
             }
          }
           // 移出屏幕底部
           else if (targetContainer.y > app.screen.height + 20) {
              console.log(`目标组合 '${currentTarget.char}' 已移出屏幕底部 (未击中)`);
              app.ticker.remove(move);
              if (app.stage.children.includes(targetContainer)) {
                  app.stage.removeChild(targetContainer);
              }
              const missedTargetData = currentTarget;
              currentTarget = null;
              currentTargetSprite = null;
              currentTargetTickerCallback = null;
              console.log(`目标 ${missedTargetData?.char || '未知目标'} 移出屏幕，准备生成下一个`);
              setTimeout(() => {
                    if (!currentTarget) {
                        createFlyingTarget();
                    }
              }, 800);
          }
        };
        currentTargetTickerCallback = move;
        app.ticker.add(move);
      }

      // 检查答案
      function checkAnswer(selectedTone) {
        if (!currentTarget) {
          console.log("当前没有目标，无法检查答案");
          return; // 如果没有目标，则不执行任何操作
        }

        console.log(`检查答案: 目标 '${currentTarget.char}'(tone ${currentTarget.tone}), 选择 tone ${selectedTone}`);

        if (currentTarget && selectedTone === currentTarget.tone) { // 加强检查
          targetHealth -= attackPower;
          console.log(`声调正确! 目标 '${currentTarget.char}' 生命值剩余: ${targetHealth}`);

          // **播放正确提示音**
          playCorrectSound();

          if (targetHealth <= 0) {
            console.log(`目标组合 '${currentTarget.char}' 已击毁! 显示拼音并朗读...`);

            if (currentTargetTickerCallback) {
              app.ticker.remove(currentTargetTickerCallback);
            }

            const destroyedContainer = currentTargetSprite;
            const finalTargetData = currentTarget; // 保存数据

            if (destroyedContainer && destroyedContainer.parent) { // 确保还在舞台上
              const hanziText = destroyedContainer.getChildByName('hanziText');
              const emojiText = destroyedContainer.getChildByName('emojiText');

              if (hanziText) {
                hanziText.visible = false;
              }

              const pinyinText = new PIXI.Text(finalTargetData.pinyin, {
                fontFamily: 'Arial', 
                fontSize: 56,
                fill: 0x000000,
                align: 'center'
              });
              pinyinText.name = 'pinyinText';
              pinyinText.anchor.set(0.5, 1);
              if (emojiText) { 
                  pinyinText.x = emojiText.x;
                  pinyinText.y = emojiText.y - emojiText.height / 2 - 5;
              } else { 
                  pinyinText.x = destroyedContainer.width / 2;
                  pinyinText.y = 0;
              }
              destroyedContainer.addChild(pinyinText);

              speak(finalTargetData.char);

              // 清理全局引用，但不移除对象
              currentTarget = null;
              currentTargetSprite = null;
              currentTargetTickerCallback = null; 

              setTimeout(() => {
                console.log(`清理被击毁的目标 ${finalTargetData.char}`);
                if (destroyedContainer.parent) { // 再次检查父对象
                  app.stage.removeChild(destroyedContainer);
                }
                // 在清理完成后，检查是否需要创建新目标
                if (playerHealth > 0 && !currentTarget) { 
                   createFlyingTarget();
                }
              }, 1500); 

            } else {
              console.error("击毁时无法找到目标 Container 或已不在舞台!");
              currentTarget = null;
              currentTargetSprite = null;
              currentTargetTickerCallback = null;
              if (playerHealth > 0) {
                 createFlyingTarget();
              }
            }

          } else {
            // 未击毁，仅显示命中效果 (注意检查 hitText 是否存在)
            const hitText = new PIXI.Text('✓ 正确!', { 
              fontFamily: 'Arial',
              fontSize: 50,
              fill: 0x00FF00,
              stroke: '#006400',
              strokeThickness: 3
            });
            hitText.x = app.screen.width / 2 - 50;
            hitText.y = 50;
            app.stage.addChild(hitText);
            
            setTimeout(() => {
              if (hitText.parent) { app.stage.removeChild(hitText); }
            }, 500);
          }

        } else if (currentTarget) { // currentTarget 存在但声调错误
            console.log(`声调错误! 目标 '${currentTarget.char}' 需要 tone ${currentTarget.tone}, 选择了 tone ${selectedTone}`);
            const missText = new PIXI.Text('✗ 声调错误!', {
              fontFamily: 'Arial',
              fontSize: 50,
              fill: 0xFF0000,
              stroke: '#8B0000',
              strokeThickness: 3
            });
            missText.x = app.screen.width / 2 - 50;
            missText.y = 50;
            app.stage.addChild(missText);
            
            setTimeout(() => {
              if (missText.parent) { app.stage.removeChild(missText); }
            }, 500);
        }
      }

      // 初始布局设置
      updateLayout(); // 创建完元素后调用一次

      // 添加 resize 事件监听
      window.addEventListener('resize', () => {
        app.resize(); // 触发 PixiJS 内部 resize
        updateLayout(); // 更新我们自己的布局
      });

      // 初始化游戏
      // createCharacterButtons();
      if (!currentTarget) { // 初始启动
          createFlyingTarget();
      }

      // 绑定音调按钮 - 并在首次点击时尝试激活 AudioContext
      let isFirstToneClick = true; // 添加标志位
      document.querySelectorAll('.tone-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // 首次点击时，尝试创建/恢复 AudioContext
          if (isFirstToneClick && !audioCtx) {
             try {
                 audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                 console.log("AudioContext created on first click.");
             } catch (e) {
                 console.error("Web Audio API is not supported.", e);
             }
          }
          if (audioCtx && audioCtx.state === 'suspended') {
             audioCtx.resume().then(() => {
                 console.log("AudioContext resumed on click.");
             }).catch(e => console.error("Error resuming AudioContext:", e));
          }
          isFirstToneClick = false; // 不再是首次点击

          const tone = parseInt(btn.dataset.tone);
          // alert(`你选择了 ${btn.textContent}，后续可以扩展音调验证功能`); // 移除 alert
          if (currentTarget) { // 确保有目标时才检查
             checkAnswer(tone); // 调用新的 checkAnswer，传入声调
          } else {
             console.log("点击声调按钮，但当前无目标");
          }
        });
      });
    }); // <-- 补上 DOMContentLoaded 的结束括号和分号
  </script>
</body>
</html>