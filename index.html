<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>æ±‰å­—éŸ³è°ƒå¤§ä½œæˆ˜</title>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.2.1/dist/pixi.min.js"></script>
  <style>
    body { margin: 0; background: #f0f0f0; overflow: hidden; }
    #game-container { position: relative; }
    #controls { 
      text-align: center; 
      position: absolute;
      bottom: 10px;
      left: 0;
      width: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 10px 0;
      box-sizing: border-box;
      z-index: 10;
    }
    .tone-btn { 
      font-size: 48px;
      margin: 10px 12px;
      padding: 18px 25px;
    }
  </style>
</head>
<body>
  <!-- æ·»åŠ æ¸¸æˆå®¹å™¨ -->
  <div id="game-container">
    <div id="controls">
      <button class="tone-btn" data-tone="1">ä¸€å£° Â¯</button>
      <button class="tone-btn" data-tone="2">äºŒå£° ËŠ</button>
      <button class="tone-btn" data-tone="3">ä¸‰å£° Ë‡</button>
      <button class="tone-btn" data-tone="4">å››å£° Ë‹</button>
    </div>
  </div>

  <script>
    // Web Audio API ç›¸å…³
    let audioCtx = null;

    function playCorrectSound() {
      if (!audioCtx) {
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.error("Web Audio API is not supported in this browser", e);
          return; // ä¸æ”¯æŒåˆ™æ— æ³•æ’­æ”¾
        }
      }

      // æ£€æŸ¥ AudioContext æ˜¯å¦å¤„äº suspended çŠ¶æ€ (å¸¸è§äºç”¨æˆ·äº¤äº’å‰)
      if (audioCtx.state === 'suspended') {
        audioCtx.resume(); // å°è¯•æ¢å¤
      }
      
      if (!audioCtx) return; // å¦‚æœåˆ›å»ºå¤±è´¥æˆ–ä¸æ”¯æŒï¼Œåˆ™é€€å‡º

      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      oscillator.type = 'sine'; // æ­£å¼¦æ³¢
      oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A5 éŸ³é«˜

      // æ§åˆ¶éŸ³é‡ï¼Œåˆ¶é€ çŸ­ä¿ƒæç¤ºéŸ³æ•ˆæœ
      const now = audioCtx.currentTime;
      const peakVolume = 0.4; // ä¸è¦å¤ªå¤§å£°
      const duration = 0.15; // å£°éŸ³æŒç»­æ—¶é—´
      gainNode.gain.setValueAtTime(0, now);
      gainNode.gain.linearRampToValueAtTime(peakVolume, now + duration * 0.2); // å¿«é€Ÿä¸Šå‡
      gainNode.gain.linearRampToValueAtTime(0, now + duration); // ç¼“æ…¢ä¸‹é™

      oscillator.start(now);
      oscillator.stop(now + duration);
    }

    // æ·»åŠ  speak å‡½æ•°
    function speak(text) {
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel(); 
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'zh-CN';
        utterance.rate = 0.9;
        window.speechSynthesis.speak(utterance);
      } else {
        console.warn("æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆ API");
      }
    }

    // ç­‰å¾…DOMåŠ è½½å®Œæˆ
    document.addEventListener('DOMContentLoaded', async () => {
      // åˆå§‹åŒ–æ¸¸æˆ
      const app = new PIXI.Application();
      await app.init({
        backgroundColor: 0xE8F4FF,
        resizeTo: window
      });
      
      // ç¡®ä¿æ­£ç¡®æ’å…¥canvas
      const container = document.getElementById('game-container');
      container.insertBefore(app.view, container.firstChild);

      // æ¸¸æˆæ•°æ®
      const characters = [
        { char: 'çŒ«', pinyin: 'mÄo', tone: 1, emoji: 'ğŸ±' },
        { char: 'ç‹—', pinyin: 'gÇ’u', tone: 3, emoji: 'ğŸ¶' },
        { char: 'ä¹¦', pinyin: 'shÅ«', tone: 1, emoji: 'ğŸ“–' },
        { char: 'ç¬”', pinyin: 'bÇ', tone: 3, emoji: 'âœï¸' },
        { char: 'æ°´', pinyin: 'shuÇ', tone: 3, emoji: 'ğŸ’§' },
        { char: 'ç«', pinyin: 'huÇ’', tone: 3, emoji: 'ğŸ”¥' },
        { char: 'å±±', pinyin: 'shÄn', tone: 1, emoji: 'â›°ï¸' },
        { char: 'äºº', pinyin: 'rÃ©n', tone: 2, emoji: 'ğŸ§‘' },
        { char: 'å¤©', pinyin: 'tiÄn', tone: 1, emoji: 'â˜€ï¸' },
        { char: 'åœ°', pinyin: 'dÃ¬', tone: 4, emoji: 'ğŸŒ' },
        { char: 'æœˆ', pinyin: 'yuÃ¨', tone: 4, emoji: 'ğŸŒ™' },
        { char: 'æ—¥', pinyin: 'rÃ¬', tone: 4, emoji: 'â˜€ï¸' },
        { char: 'æ˜Ÿ', pinyin: 'xÄ«ng', tone: 1, emoji: 'â­' },
        { char: 'äº‘', pinyin: 'yÃºn', tone: 2, emoji: 'â˜ï¸' },
        { char: 'é£', pinyin: 'fÄ“ng', tone: 1, emoji: 'ğŸŒ¬ï¸' },
        { char: 'é›¨', pinyin: 'yÇ”', tone: 3, emoji: 'ğŸŒ§ï¸' },
        { char: 'ç”µ', pinyin: 'diÃ n', tone: 4, emoji: 'âš¡' },
        { char: 'èŠ±', pinyin: 'huÄ', tone: 1, emoji: 'ğŸŒ¸' },
        { char: 'è‰', pinyin: 'cÇo', tone: 3, emoji: 'ğŸŒ¿' },
        { char: 'æ ‘', pinyin: 'shÃ¹', tone: 4, emoji: 'ğŸŒ³' },
        { char: 'é¸Ÿ', pinyin: 'niÇo', tone: 3, emoji: 'ğŸ¦' },
        { char: 'é±¼', pinyin: 'yÃº', tone: 2, emoji: 'ğŸŸ' },
        { char: 'é©¬', pinyin: 'mÇ', tone: 3, emoji: 'ğŸ' },
        { char: 'ç‰›', pinyin: 'niÃº', tone: 2, emoji: 'ğŸ‚' },
        { char: 'ç¾Š', pinyin: 'yÃ¡ng', tone: 2, emoji: 'ğŸ‘' },
        { char: 'å·¦', pinyin: 'zuÇ’', tone: 3, emoji: 'ğŸ‘ˆ' },
        { char: 'å³', pinyin: 'yÃ²u', tone: 4, emoji: 'ğŸ‘‰' },
        { char: 'å¤§', pinyin: 'dÃ ', tone: 4, emoji: 'ğŸ˜' },
        { char: 'å°', pinyin: 'xiÇo', tone: 3, emoji: 'ğŸ­' },
        { char: 'è½¦', pinyin: 'chÄ“', tone: 1, emoji: 'ğŸš—' },
        { char: 'èˆ¹', pinyin: 'chuÃ¡n', tone: 2, emoji: 'ğŸš¢' },
        { char: 'é—¨', pinyin: 'mÃ©n', tone: 2, emoji: 'ğŸšª' },
        { char: 'åˆ€', pinyin: 'dÄo', tone: 1, emoji: 'ğŸ”ª' },
        { char: 'è¡£', pinyin: 'yÄ«', tone: 1, emoji: 'ğŸ‘•' },
        { char: 'é£Ÿ', pinyin: 'shÃ­', tone: 2, emoji: 'ğŸ”' },
        { char: 'ä½', pinyin: 'zhÃ¹', tone: 4, emoji: 'ğŸ ' },
        { char: 'è¡Œ', pinyin: 'xÃ­ng', tone: 2, emoji: 'ğŸš¶' },
        { char: 'æ‰‹', pinyin: 'shÇ’u', tone: 3, emoji: 'âœ‹' },
        { char: 'è¶³', pinyin: 'zÃº', tone: 2, emoji: 'ğŸ¦¶' },
        { char: 'å¤´', pinyin: 'tÃ³u', tone: 2, emoji: 'ğŸ‘¤' },
        { char: 'å¿ƒ', pinyin: 'xÄ«n', tone: 1, emoji: 'â¤ï¸' },
        { char: 'çœ¼', pinyin: 'yÇn', tone: 3, emoji: 'ğŸ‘€' },
        { char: 'è€³', pinyin: 'Ä›r', tone: 3, emoji: 'ğŸ‘‚' },
        { char: 'å£', pinyin: 'kÇ’u', tone: 3, emoji: 'ğŸ‘„' },
        { char: 'é¼»', pinyin: 'bÃ­', tone: 2, emoji: 'ğŸ‘ƒ' },
        { char: 'ç¬‘', pinyin: 'xiÃ o', tone: 4, emoji: 'ğŸ˜„' },
        { char: 'å“­', pinyin: 'kÅ«', tone: 1, emoji: 'ğŸ˜­' },
        { char: 'çˆ±', pinyin: 'Ã i', tone: 4, emoji: 'â¤ï¸' },
        { char: 'é’±', pinyin: 'qiÃ¡n', tone: 2, emoji: 'ğŸ’°' },
        { char: 'çƒ', pinyin: 'qiÃº', tone: 2, emoji: 'âš½' },
        { char: 'ç¯', pinyin: 'dÄ“ng', tone: 1, emoji: 'ğŸ’¡' },
        { char: 'ç”»', pinyin: 'huÃ ', tone: 4, emoji: 'ğŸ–¼ï¸' },
        { char: 'å”±', pinyin: 'chÃ ng', tone: 4, emoji: 'ğŸ¤' },
        { char: 'è·³', pinyin: 'tiÃ o', tone: 4, emoji: 'ğŸ’ƒ' },
        { char: 'è·‘', pinyin: 'pÇo', tone: 3, emoji: 'ğŸƒ' },
        { char: 'é£', pinyin: 'fÄ“i', tone: 1, emoji: 'âœˆï¸' },
        { char: 'å', pinyin: 'zuÃ²', tone: 4, emoji: 'ğŸª‘' },
        { char: 'ç«™', pinyin: 'zhÃ n', tone: 4, emoji: 'ğŸ§' }
      ];

      let currentTarget = null;
      let targetHealth = 0;
      let currentTargetSprite = null; // æ–°å¢ï¼šå­˜å‚¨å½“å‰ç›®æ ‡çš„ PIXI å¯¹è±¡
      let currentTargetTickerCallback = null; // æ–°å¢ï¼šå­˜å‚¨å½“å‰ç›®æ ‡çš„ Ticker å›è°ƒ
      const attackPower = 15;

      // æ–°å¢ï¼šç©å®¶æ•°æ®
      let playerHealth = 100; // åˆå§‹ç”Ÿå‘½å€¼
      let playerPosition = { x: 0, y: 0 }; // æ”¹ä¸ºå˜é‡ï¼ŒåŠ¨æ€è®¡ç®—
      let playerSprite = null; // ç©å®¶çš„ PIXI å¯¹è±¡
      let healthText = null; // æ˜¾ç¤ºç”Ÿå‘½å€¼çš„ PIXI.Text å¯¹è±¡
      // let playerScore = 0; // å¦‚æœéœ€è¦åˆ†æ•°ï¼Œå–æ¶ˆæ³¨é‡Š
      // let scoreText = null;

      // åˆ›å»ºæ“ä½œåŒº (å®šä¹‰é«˜åº¦å˜é‡)
      const controlAreaHeight = 100;
      const controlArea = new PIXI.Graphics();
      app.stage.addChild(controlArea); // å…ˆæ·»åŠ ï¼Œåç»­åœ¨ updateLayout ä¸­ç»˜åˆ¶ (ç°åœ¨ä¸ç»˜åˆ¶äº†)

      // åˆ›å»ºç©å®¶å›¾å½¢ (ä½¿ç”¨ SVG ç›¾ç‰Œ)
      const playerSvgString = '<svg width="60" height="70" viewBox="0 0 60 70" xmlns="http://www.w3.org/2000/svg"><path d="M 5 15 A 25 25 0 0 1 55 15 L 55 50 L 30 65 L 5 50 Z" fill="dodgerblue" stroke="black" stroke-width="2"/></svg>';
      playerSprite = new PIXI.Graphics().svg(playerSvgString);
      playerSprite.scale.set(2.5, 2.5); // å°†ç©å®¶ç›¾ç‰Œæ”¾å¤§åˆ° 2.5 å€
      console.log("ç©å®¶ (SVGç›¾ç‰Œ) å·²åˆ›å»ºå¹¶æ·»åŠ åˆ°èˆå°ï¼Œå·²ç¼©æ”¾");

      // å®šä½ç©å®¶ (åŸºäºæ–°çš„ SVG å›¾å½¢å°ºå¯¸è‡ªåŠ¨è®¡ç®—å±…ä¸­)
      playerSprite.x = playerPosition.x - playerSprite.width / 2; 
      playerSprite.y = playerPosition.y - playerSprite.height / 2;
      app.stage.addChild(playerSprite);
      console.log("ç©å®¶ (SVGç›¾ç‰Œ) å·²åˆ›å»ºå¹¶æ·»åŠ åˆ°èˆå°ï¼Œå·²ç¼©æ”¾");

      // åˆ›å»ºç”Ÿå‘½å€¼æ–‡æœ¬
      healthText = new PIXI.Text(`ç”Ÿå‘½å€¼: ${playerHealth}`, {
        fontFamily: 'Arial',
        fontSize: 42,
        fill: 0x000000 // é»‘è‰²
      });
      healthText.x = 10; // æ”¾åœ¨å·¦ä¸Šè§’
      healthText.y = 10;
      app.stage.addChild(healthText);
      console.log("ç”Ÿå‘½å€¼æ–‡æœ¬å·²åˆ›å»º");

      // åˆ›å»ºæ±‰å­—æŒ‰é’® (ç°åœ¨æ³¨é‡Šæ‰ï¼Œå› ä¸ºä¸å†éœ€è¦)
      // createCharacterButtons();

      // å®šä¹‰ updateLayout å‡½æ•°
      function updateLayout() {
        console.log(`Updating layout for screen: ${app.screen.width}x${app.screen.height}`);
        // æ›´æ–°ç©å®¶ä½ç½® (åº•éƒ¨å±…ä¸­ï¼Œæ ¹æ®æŒ‰é’®åŒºåŸŸå’Œæ”¾å¤§çš„ç›¾ç‰Œå‘ä¸Šåç§»)
        const controlsHeightEstimate = 160; // å†æ¬¡è°ƒæ•´åº•éƒ¨æŒ‰é’®åŒºåŸŸé«˜åº¦ä¼°ç®—
        playerPosition.x = app.screen.width / 2;
        playerPosition.y = app.screen.height - (playerSprite.height * playerSprite.scale.y) / 2 - controlsHeightEstimate - 15; // é¢å¤–å†å‘ä¸Šç§»15pxè¾¹è·

        // æ›´æ–°ç©å®¶ Sprite ä½ç½®
        if (playerSprite) {
             playerSprite.x = playerPosition.x - playerSprite.width / 2; 
             playerSprite.y = playerPosition.y - playerSprite.height / 2;
        }

        // æ›´æ–°æ“ä½œåŒºç»˜åˆ¶ (ä¸å†éœ€è¦ç»˜åˆ¶ç”»å¸ƒä¸Šçš„æ“ä½œåŒº)
        /*
        controlArea.clear(); // æ¸…é™¤æ—§çš„ç»˜åˆ¶
        controlArea.beginFill(0xFFFFFF, 0.7)
                   .drawRect(0, app.screen.height - controlAreaHeight, app.screen.width, controlAreaHeight)
                   .endFill();
        */
      }

      // åˆ›å»ºé£æ¥çš„ç›®æ ‡ (ç»„åˆå½¢å¼ï¼šæ•Œäºº + å¤´é¡¶æ–‡å­—)
      function createFlyingTarget() {
        const targetCharIndex = Math.floor(Math.random() * characters.length);
        const targetChar = characters[targetCharIndex];

        if (!targetChar) {
          console.error("æ— æ³•è·å–ç›®æ ‡æ±‰å­—æ•°æ®!");
          setTimeout(createFlyingTarget, 1000);
          return;
        }

        console.log("åˆ›å»ºæ–°ç›®æ ‡ç»„åˆ:", targetChar.char);
        currentTarget = targetChar;
        targetHealth = 30; // é‡ç½®ç”Ÿå‘½å€¼
        
        // åˆ›å»º Container
        const targetContainer = new PIXI.Container();
        targetContainer.charData = currentTarget; // å°†æ•°æ®å…³è”åˆ° Container

        // 1. åˆ›å»ºæ•Œäºº Emoji æ–‡æœ¬ (æ·»åŠ  name)
        const enemyEmojiText = new PIXI.Text(currentTarget.emoji, { 
            fontFamily: 'Arial', 
            fontSize: 100 /* å†æ¬¡å¢å¤§ Emoji */
        });
        enemyEmojiText.name = 'emojiText'; // æ·»åŠ åç§°
        enemyEmojiText.x = 0;
        enemyEmojiText.y = 0;
        enemyEmojiText.anchor.set(0.5, 0.5);
        targetContainer.addChild(enemyEmojiText);

        // 2. åˆ›å»ºæ±‰å­—æ–‡æœ¬ (æ·»åŠ  name)
        const charText = new PIXI.Text(currentTarget.char, { 
            fontFamily: 'Arial', 
            fontSize: 56,
            fill: 0x000000, align: 'center' 
        });
        charText.name = 'hanziText'; // æ·»åŠ åç§°
        charText.anchor.set(0.5, 1);
        charText.x = enemyEmojiText.x;
        charText.y = enemyEmojiText.y - enemyEmojiText.height / 2 - 5;
        targetContainer.addChild(charText);

        // è®¾ç½® Container çš„åˆå§‹ä½ç½® (åŸºäºæ–°çš„å†…å®¹)
        const containerBounds = targetContainer.getLocalBounds(); // è·å–å±€éƒ¨è¾¹ç•Œæ¥ä¼°ç®—å°ºå¯¸
        targetContainer.x = Math.random() * (app.screen.width - containerBounds.width);
        targetContainer.y = -containerBounds.height; // ä»å±å¹•é¡¶éƒ¨å¤–å¼€å§‹

        currentTargetSprite = targetContainer; 
        app.stage.addChild(targetContainer);
        console.log(`ç›®æ ‡ç»„åˆ '${currentTarget.char}' å·²æ·»åŠ åˆ°èˆå°...`);

        // **æœ—è¯»æ±‰å­—**
        speak(currentTarget.char);

        // ç§»åŠ¨ Container çš„é€»è¾‘
        const move = (ticker) => { 
          const delta = ticker.deltaTime;
          const speed = 1.5; // åŠ å¿«é€Ÿåº¦ (åŸä¸º 0.8)

          // è®¡ç®—æœå‘ç©å®¶çš„æ–¹å‘å‘é‡ (ç›®æ ‡æ˜¯ Container çš„ä¸­å¿ƒ)
          const dx = playerPosition.x - (targetContainer.x + containerBounds.width / 2);
          const dy = playerPosition.y - (targetContainer.y + containerBounds.height / 2);
          const length = Math.sqrt(dx * dx + dy * dy);

          if (length > 1) { 
            const normalizedDx = dx / length;
            const normalizedDy = dy / length;
            targetContainer.x += normalizedDx * speed * delta;
            targetContainer.y += normalizedDy * speed * delta;
          }

          // ç¢°æ’æ£€æµ‹é€»è¾‘
          const enemyBoundsRect = targetContainer.getBounds().rectangle; 
          const playerBoundsRect = playerSprite.getBounds().rectangle; 

          if (enemyBoundsRect && playerBoundsRect && enemyBoundsRect.intersects(playerBoundsRect)) { 
             console.log(`ç›®æ ‡ç»„åˆ '${currentTarget.char}' å‡»ä¸­ç©å®¶!`);
             // å‡å°‘ç©å®¶ç”Ÿå‘½å€¼
             playerHealth -= 10; // æ¯æ¬¡å‡»ä¸­å‡å°‘ 10 ç‚¹ç”Ÿå‘½å€¼
             healthText.text = `ç”Ÿå‘½å€¼: ${playerHealth}`; // æ›´æ–°æ˜¾ç¤º
             console.log(`ç©å®¶ç”Ÿå‘½å€¼å‰©ä½™: ${playerHealth}`);

             // ç§»é™¤æ•Œäºº
             app.ticker.remove(move);
             if (app.stage.children.includes(targetContainer)) {
                app.stage.removeChild(targetContainer);
             }
             // æ¸…ç†çŠ¶æ€
             const hitTargetData = currentTarget; 
             currentTarget = null;
             currentTargetSprite = null;
             currentTargetTickerCallback = null;

             if (playerHealth <= 0) {
               console.log("æ¸¸æˆç»“æŸ!");
               healthText.text = "æ¸¸æˆç»“æŸ!"; // æ›´æ–°æ–‡æœ¬æç¤º
               // (å¾…å®ç°) æ˜¾ç¤ºæ¸¸æˆç»“æŸç”»é¢æˆ–æç¤º
               app.ticker.stop(); // åœæ­¢æ‰€æœ‰ ticker æ›´æ–°ï¼Œæš‚åœæ¸¸æˆ
             } else {
                console.log(`ç©å®¶è¢« ${hitTargetData?.char || 'æœªçŸ¥ç›®æ ‡'} å‡»ä¸­ï¼Œå‡†å¤‡ç”Ÿæˆä¸‹ä¸€ä¸ª`);
                setTimeout(() => {
                     if (!currentTarget) { 
                        createFlyingTarget();
                     }
                }, 500); 
             }
          }
           // ç§»å‡ºå±å¹•åº•éƒ¨
           else if (targetContainer.y > app.screen.height + 20) {
              console.log(`ç›®æ ‡ç»„åˆ '${currentTarget.char}' å·²ç§»å‡ºå±å¹•åº•éƒ¨ (æœªå‡»ä¸­)`);
              app.ticker.remove(move);
              if (app.stage.children.includes(targetContainer)) {
                  app.stage.removeChild(targetContainer);
              }
              const missedTargetData = currentTarget;
              currentTarget = null;
              currentTargetSprite = null;
              currentTargetTickerCallback = null;
              console.log(`ç›®æ ‡ ${missedTargetData?.char || 'æœªçŸ¥ç›®æ ‡'} ç§»å‡ºå±å¹•ï¼Œå‡†å¤‡ç”Ÿæˆä¸‹ä¸€ä¸ª`);
              setTimeout(() => {
                    if (!currentTarget) {
                        createFlyingTarget();
                    }
              }, 800);
          }
        };
        currentTargetTickerCallback = move;
        app.ticker.add(move);
      }

      // æ£€æŸ¥ç­”æ¡ˆ
      function checkAnswer(selectedTone) {
        if (!currentTarget) {
          console.log("å½“å‰æ²¡æœ‰ç›®æ ‡ï¼Œæ— æ³•æ£€æŸ¥ç­”æ¡ˆ");
          return; // å¦‚æœæ²¡æœ‰ç›®æ ‡ï¼Œåˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œ
        }

        console.log(`æ£€æŸ¥ç­”æ¡ˆ: ç›®æ ‡ '${currentTarget.char}'(tone ${currentTarget.tone}), é€‰æ‹© tone ${selectedTone}`);

        if (currentTarget && selectedTone === currentTarget.tone) { // åŠ å¼ºæ£€æŸ¥
          targetHealth -= attackPower;
          console.log(`å£°è°ƒæ­£ç¡®! ç›®æ ‡ '${currentTarget.char}' ç”Ÿå‘½å€¼å‰©ä½™: ${targetHealth}`);

          // **æ’­æ”¾æ­£ç¡®æç¤ºéŸ³**
          playCorrectSound();

          if (targetHealth <= 0) {
            console.log(`ç›®æ ‡ç»„åˆ '${currentTarget.char}' å·²å‡»æ¯! æ˜¾ç¤ºæ‹¼éŸ³å¹¶æœ—è¯»...`);

            if (currentTargetTickerCallback) {
              app.ticker.remove(currentTargetTickerCallback);
            }

            const destroyedContainer = currentTargetSprite;
            const finalTargetData = currentTarget; // ä¿å­˜æ•°æ®

            if (destroyedContainer && destroyedContainer.parent) { // ç¡®ä¿è¿˜åœ¨èˆå°ä¸Š
              const hanziText = destroyedContainer.getChildByName('hanziText');
              const emojiText = destroyedContainer.getChildByName('emojiText');

              if (hanziText) {
                hanziText.visible = false;
              }

              const pinyinText = new PIXI.Text(finalTargetData.pinyin, {
                fontFamily: 'Arial', 
                fontSize: 56,
                fill: 0x000000,
                align: 'center'
              });
              pinyinText.name = 'pinyinText';
              pinyinText.anchor.set(0.5, 1);
              if (emojiText) { 
                  pinyinText.x = emojiText.x;
                  pinyinText.y = emojiText.y - emojiText.height / 2 - 5;
              } else { 
                  pinyinText.x = destroyedContainer.width / 2;
                  pinyinText.y = 0;
              }
              destroyedContainer.addChild(pinyinText);

              speak(finalTargetData.char);

              // æ¸…ç†å…¨å±€å¼•ç”¨ï¼Œä½†ä¸ç§»é™¤å¯¹è±¡
              currentTarget = null;
              currentTargetSprite = null;
              currentTargetTickerCallback = null; 

              setTimeout(() => {
                console.log(`æ¸…ç†è¢«å‡»æ¯çš„ç›®æ ‡ ${finalTargetData.char}`);
                if (destroyedContainer.parent) { // å†æ¬¡æ£€æŸ¥çˆ¶å¯¹è±¡
                  app.stage.removeChild(destroyedContainer);
                }
                // åœ¨æ¸…ç†å®Œæˆåï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºæ–°ç›®æ ‡
                if (playerHealth > 0 && !currentTarget) { 
                   createFlyingTarget();
                }
              }, 1500); 

            } else {
              console.error("å‡»æ¯æ—¶æ— æ³•æ‰¾åˆ°ç›®æ ‡ Container æˆ–å·²ä¸åœ¨èˆå°!");
              currentTarget = null;
              currentTargetSprite = null;
              currentTargetTickerCallback = null;
              if (playerHealth > 0) {
                 createFlyingTarget();
              }
            }

          } else {
            // æœªå‡»æ¯ï¼Œä»…æ˜¾ç¤ºå‘½ä¸­æ•ˆæœ (æ³¨æ„æ£€æŸ¥ hitText æ˜¯å¦å­˜åœ¨)
            const hitText = new PIXI.Text('âœ“ æ­£ç¡®!', { 
              fontFamily: 'Arial',
              fontSize: 50,
              fill: 0x00FF00,
              stroke: '#006400',
              strokeThickness: 3
            });
            hitText.x = app.screen.width / 2 - 50;
            hitText.y = 50;
            app.stage.addChild(hitText);
            
            setTimeout(() => {
              if (hitText.parent) { app.stage.removeChild(hitText); }
            }, 500);
          }

        } else if (currentTarget) { // currentTarget å­˜åœ¨ä½†å£°è°ƒé”™è¯¯
            console.log(`å£°è°ƒé”™è¯¯! ç›®æ ‡ '${currentTarget.char}' éœ€è¦ tone ${currentTarget.tone}, é€‰æ‹©äº† tone ${selectedTone}`);
            const missText = new PIXI.Text('âœ— å£°è°ƒé”™è¯¯!', {
              fontFamily: 'Arial',
              fontSize: 50,
              fill: 0xFF0000,
              stroke: '#8B0000',
              strokeThickness: 3
            });
            missText.x = app.screen.width / 2 - 50;
            missText.y = 50;
            app.stage.addChild(missText);
            
            setTimeout(() => {
              if (missText.parent) { app.stage.removeChild(missText); }
            }, 500);
        }
      }

      // åˆå§‹å¸ƒå±€è®¾ç½®
      updateLayout(); // åˆ›å»ºå®Œå…ƒç´ åè°ƒç”¨ä¸€æ¬¡

      // æ·»åŠ  resize äº‹ä»¶ç›‘å¬
      window.addEventListener('resize', () => {
        app.resize(); // è§¦å‘ PixiJS å†…éƒ¨ resize
        updateLayout(); // æ›´æ–°æˆ‘ä»¬è‡ªå·±çš„å¸ƒå±€
      });

      // åˆå§‹åŒ–æ¸¸æˆ
      // createCharacterButtons();
      if (!currentTarget) { // åˆå§‹å¯åŠ¨
          createFlyingTarget();
      }

      // ç»‘å®šéŸ³è°ƒæŒ‰é’® - å¹¶åœ¨é¦–æ¬¡ç‚¹å‡»æ—¶å°è¯•æ¿€æ´» AudioContext
      let isFirstToneClick = true; // æ·»åŠ æ ‡å¿—ä½
      document.querySelectorAll('.tone-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // é¦–æ¬¡ç‚¹å‡»æ—¶ï¼Œå°è¯•åˆ›å»º/æ¢å¤ AudioContext
          if (isFirstToneClick && !audioCtx) {
             try {
                 audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                 console.log("AudioContext created on first click.");
             } catch (e) {
                 console.error("Web Audio API is not supported.", e);
             }
          }
          if (audioCtx && audioCtx.state === 'suspended') {
             audioCtx.resume().then(() => {
                 console.log("AudioContext resumed on click.");
             }).catch(e => console.error("Error resuming AudioContext:", e));
          }
          isFirstToneClick = false; // ä¸å†æ˜¯é¦–æ¬¡ç‚¹å‡»

          const tone = parseInt(btn.dataset.tone);
          // alert(`ä½ é€‰æ‹©äº† ${btn.textContent}ï¼Œåç»­å¯ä»¥æ‰©å±•éŸ³è°ƒéªŒè¯åŠŸèƒ½`); // ç§»é™¤ alert
          if (currentTarget) { // ç¡®ä¿æœ‰ç›®æ ‡æ—¶æ‰æ£€æŸ¥
             checkAnswer(tone); // è°ƒç”¨æ–°çš„ checkAnswerï¼Œä¼ å…¥å£°è°ƒ
          } else {
             console.log("ç‚¹å‡»å£°è°ƒæŒ‰é’®ï¼Œä½†å½“å‰æ— ç›®æ ‡");
          }
        });
      });
    }); // <-- è¡¥ä¸Š DOMContentLoaded çš„ç»“æŸæ‹¬å·å’Œåˆ†å·
  </script>
</body>
</html>